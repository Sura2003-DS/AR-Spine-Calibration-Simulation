<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>AR Calibration for Spine Surgery</title>
  <link rel="stylesheet" href="style.css">

  <!-- Three.js (only needed for 3D viewer) -->
  <!-- Three.js -->
<script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>

<!-- OBJLoader -->
<script src="https://unpkg.com/three@0.152.2/examples/js/loaders/OBJLoader.js"></script>

</head>
<body>
  <h1>Reducing Calibration Error in AR-assisted Spine Surgery</h1>

  <section>
    <h2>Overview</h2>
    <p>
      This project uses CT scans and vertebra segmentations (VerSe dataset) to build 3D spine models
      and simulate AR calibration. Calibration error is measured as translation (mm) and rotation (degrees)
      between the CT-based model and a simulated AR tracker frame.
    </p>
  </section>

  <section>
    <h2>CT and Vertebra Segmentation</h2>
    <img src="ct_labels.png" alt="CT with vertebra labels" width="400">
    <img src="vertebra_meshlab.png" alt="3D vertebra mesh in MeshLab" width="400">

    <p>
      Left: CT slices with colored vertebra labels.
      Right: 3D mesh of a single vertebra generated from the label map using the marching-cubes algorithm.
    </p>
  </section>

  <section>
    <h2>Calibration Error Results</h2>
    <table>
      <tr>
        <th>K (landmarks)</th>
        <th>Noise σ (mm)</th>
        <th>Mean translation error (mm)</th>
        <th>Mean rotation error (deg)</th>
      </tr>
      <tr>
        <td>10</td><td>1.5</td><td>8.6 ± 4.8</td><td>2.8 ± 1.3</td>
      </tr>
      <tr>
        <td>20</td><td>1.0</td><td>4.5 ± 2.5</td><td>2.1 ± 1.0</td>
      </tr>
      <tr>
        <td>30</td><td>0.5</td><td>≈2–3</td><td>≈1–2</td>
      </tr>
    </table>

    <div class="plots">
      <img src="trans_error.png" alt="Translation error vs noise / landmarks">
      <img src="rot_error.png" alt="Rotation error vs noise / landmarks">
    </div>

    <p>
      The blue, orange, and green curves correspond to K = 10, 20, and 30 landmarks.
      As the number of landmarks increases and the noise σ decreases, both translation
      and rotation calibration errors move downwards, indicating improved AR calibration accuracy.
    </p>
  </section>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Working Three.js + OBJLoader Demo</title>

 <script src="https://unpkg.com/three@0.146.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.146.0/examples/js/loaders/OBJLoader.js"></script>


  <style>
    body { background: #111; color: white; font-family: Arial; }
    #viewer { width: 600px; height: 400px; margin-top: 20px; border: 1px solid #555; }
  </style>
</head>

<body>

<h1>Three.js + OBJLoader (Working Demo)</h1>
<p>

</p>

<div id="viewer"></div>

<script>
  console.log("THREE =", THREE);
  console.log("OBJLoader =", THREE.OBJLoader);

  // Create scene
  const container = document.getElementById("viewer");
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x222222);

  // Camera
  const camera = new THREE.PerspectiveCamera(45, 600/400, 0.1, 1000);
  camera.position.z = 800;

  // Renderer
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(600, 400);
  container.appendChild(renderer.domElement);

  // Lights
  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(1,1,1).normalize();
  scene.add(light);

  const ambient = new THREE.AmbientLight(0x404040);
  scene.add(ambient);

  // ----- A rotating cube (guaranteed to work) -----
  const geometry = new THREE.BoxGeometry();
  const material = new THREE.MeshPhongMaterial({ color: 0x00ffcc });
  const cube = new THREE.Mesh(geometry, material);
  scene.add(cube);

  // ----- OBJ Loader demo -----
  const loader = new THREE.OBJLoader();

loader.load(
  "sub-gl003_dir-ax_lab1.obj",
  function (obj) {

    console.log("OBJ Loaded Successfully!");

    // 1. SCALE (your model is huge, so scale it down)
    obj.scale.set(8, 8, 8);

    // 2. CENTER the model (important!)
    let box = new THREE.Box3().setFromObject(obj);
    let center = box.getCenter(new THREE.Vector3());
    obj.position.sub(center);  // move to origin

    // 3. Move it slightly down so it's visible above center
    obj.position.y -= 20;

    // 4. Add bright shading so mesh is visible
    obj.traverse(child => {
      if (child.isMesh) {
        child.material = new THREE.MeshNormalMaterial(); // rainbow colors
        child.geometry.computeVertexNormals();            // ensure lighting
      }
    });

    scene.add(obj);

    // 5. Animate
    function animate() {
      requestAnimationFrame(animate);
      obj.rotation.y += 0.01;
      renderer.render(scene, camera);
    }
    animate();
  },
  undefined,
  function (err) {
    console.error("OBJ load error:", err);
  }
);
 

</script>

</body>
</html>
